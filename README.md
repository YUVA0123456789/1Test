Page # 1
ASSEMBLY LANGUAGE PROGRAMS USING 8086 MP

1. Arithmetic operations on Hex and BCD numbers
* ADDITION OF TWO NUMBERS:
CODE SEGMENT
ASSUME CS: CODE
START: MOV AX,1234H
MOV BX,2345H
ADD AX, BX
HLT
CODE ENDS
END START

* SUBSTRACTION OF TWO NUMBERS:
CODE SEGMENT
ASSUME CS: CODE
START: MOV AX,2345H
MOV BX,1234H
SUB AX, BX
HLT
CODE ENDS
END START

* MULTIPLICATION OF TWO NUMBERS:
CODE SEGMENT
ASSUME CS: CODE
START: MOV AX,12H
MOV BX,12H
MUL BX
HLT
CODE ENDS

END START

* DIVISION OF TWO NUMBERS:
CODE SEGMENT
ASSUME CS: CODE
START: MOV AX,100H
MOV BX,2H
DIV BX
HLT
CODE ENDS
ENDS START

 


Page # 3
2.Sum of Series

DATA SEGMENT
    A DB 1,2,3,4,5,6,7,8,9,10
DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    MOV CL, 10
    LEA SI, A
    MOV AH, 00
    MOV AL, 00
L1:
    ADD AL, [SI] ; Square brackets to dereference SI
    INC SI
    DEC CL
    CMP CL, 00
    JNZ L1
    MOV AH, 4CH
    INT 21H
CODE ENDS
END START

 


Page # 4
3. Smallest and Largest numbers in array

* Smallest:
DATA SEGMENT
    STR1 DB 99H,01H,32H,47H,73H
    RESULT DB 0
DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    MOV CL, 05H
    LEA SI, STR1
    MOV AL, [SI]
LOC1:
    CMP AL, [SI+1]
    JB LOC2
    MOV AL, [SI+1]
LOC2:
    INC SI
    DEC CL
    JNZ LOC1
    MOV RESULT, AL
    MOV AH, 4CH
    INT 21H
CODE ENDS
END START

* Largest:
DATA SEGMENT
    STR1 DB 99H,01H,34H,42H,75H
    RESULT DB 0
DATA ENDS
CODE SEGMENT
    ASSUME CS:CODE,DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    LEA SI, STR1
    MOV CL, 05H
    DEC CL
    MOV AL, [SI]
LOC1:
    CMP AL, [SI+1]
    JA LOC2 ; If AL > [SI+1], jump to LOC2
    MOV AL, [SI+1]
LOC2:
    INC SI
    DEC CL
    JNZ LOC1 ; Jumps to LOC1 if CL is not zero
    MOV RESULT, AL
    MOV AH, 4CH
    INT 21H
CODE ENDS
END START


 


Page # 6
4.Sorting numbers in ascending and descending order

* Ascending Order:
DATA SEGMENT
STR1 DB 99H,12H,40H,72H,36H
DATA ENDS
CODE SEGMENT
ASSUME DS:DATA,CS:CODE
START:
MOV AX,DATA
MOV CH,04H
UP2:
MOV CL,04H
LEA SI,STR1
UP1:
MOV ALSI]
MOV BL{SI+1]
CMP AL,BL
JC DOWN ;JC=jump if carry,if in previous al<bl and there
is carry, it will jump to DOWN
MOV DL|SI+1]
XCHG [SI],DL
MOV [SI+1],DL
DOWN:
INC SI
DEC CL
JNZ UP1 ;jumps to up1 if CL is not zero
DEC CH
JNZ UP2 jjumps to up2 if CH is not zero
INT 3

CODE ENDS
END START

* Descending:
DATA SEGMENT
STR1 DB 99H,12H,40H,72H,36H
DATA ENDS
CODE SEGMENT
ASSUME DS:DATA,CS:CODE
START:
MOV AX,DATA
MOV CH,04H
UP2:
MOV CL,04H
LEA SISTR1
UP1:
MOV AL[SI]
MOV BLSI+1]
CMP AL,BL
JAE DOWN ;JC=jump if carry,if in previous al<bl and there is
carry, it will jump to DOWN
MOV DL|SI+1]
XCHG [SI],DL
MOV [SI+1],DL
DOWN:
INC SI
DEC CL
JNZ UP1 ;jumps to up] if CL is not zero
DEC CH
JNZ UP2 ;jumps to up2 if CH is not zero
INT 3
CODE ENDS
END START

Page # 8
5.Finding ODD, EVEN, POSITIVE and NEGATIVE number in an
array

* Odd or Even:

DATA SEGMENT
N DW 12H
MSG1 DB "ODD S$"
MSG2 DB "EVEN S"
DATA ENDS
PRINT MACRO MSG
MOV AH,09H
LEA DX,MSG
INT 21H
INT 3H
ENDM
CODE SEGMENT
ASSUME CS:CODE,DS:DATA,EX:EXTRA
START:MOV AX,DATA
MOV DS,AX
MOV AX,N
ROL AX,1
JNC ODD
EVEN:PRINT MSG2
JMP LAST
ODD: PRINT MSG1
LAST : MOV AH,4DH
INT 21H
CODE ENDS
END START

 


Page # 9
* Positive or Negative:

DATA SEGMENT
N DW 12H
MSG1 DB "POSITIVE $"
MSG2 DB "NEGATIVES"
DATA ENDS
PRINT MACRO MSG
MOV AH,09H
LEA DX,MSG
INT 21H
INT 3H
ENDM
CODE SEGMENT
ASSUME CS:CODE,DS:DATA,ES:EXTRA
START:MOV AX,DATA
MOV DS,AX
MOV AX,N
ROL AX,1
JNC NEG
POS:PRINT MSG2
NEG: PRINT MSG1
LAST : MOV AH,4DH
INT 21H
CODE ENDS
END START

 


Page # 10
DATA SEGMENT
    STR1 DB "HELLO$"
    STR2 DB "WORLD$"
DATA ENDS
CODE SEGMENT
    ASSUME DS:DATA,CS:CODE
START:
    MOV AX, DATA
    MOV DS, AX
    MOV SI, OFFSET STR1
NEXT:
    MOV AL, [SI]
    CMP AL, "$"
    JE EXIT ; If AL == "$", then jump to EXIT
    INC SI
    JMP NEXT
EXIT:
    MOV DI, OFFSET STR2
UP:
    MOV AL, [DI]
    CMP AL, "$"
    JE EXIT1
    MOV [SI], AL
    INC SI
    INC DI
    JMP UP
EXIT1:
    MOV AL, "$"
    MOV [SI], AL
    MOV AH, 4CH
CODE ENDS
END START

 


Page # 11
7. String operations-length

DATA SEGMENT
SIG DB "MICROPROCESSORS"
LEN DBO
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA,ES:EXTRA
START:
MOV AX,DATA
MOV DS,AX
LEA DI,SIG
MOV AL,24H _ ;24H is the ascii code for'$'.
MOV BL,OOH
DO:
INC BL
SCASB ;compare the vale at AL(S) with Dl(String).
JNZ DO;it wil; jump to DO if AL and DI are not equal.
JMP DONE
DONE:
DEC BL ;we will decrement the BL once to get the correct length of string.
MOV LEN,BL
MOV AH,4CH
INT 21H
CODE ENDS
END START

 


Page # 12
8. String Reverse
DATA SEGMENT
STR1 DS 01H,02H,03H,04H,05H
STR2 DS 5 DUP(0)
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
LEA SI,STR1
LEA DI,STR2+4 we are intializing DI to the fifth position of the string2
MOV CX,05H
BACK:
CLD
MOV AL [S|]
MOV [DI],AL
INC SI
DEC DI
JNZ BACK
INT 3
CODE ENDS
END START

 


Page # 13
9. String Compare
DATA SEGMENT
BLOCK1 DB 'MALAYALAM'
MSG1 DB "IT IS PALINDROME $"
MSG2 DB "IT IS NOT A PALINDROME $"
PAL DB 00H
DATA ENDS
PRINT MACRO MSG
MOV AH,09H
LEA DX,MSG
INT 21H
INT 3H
ENDM
EXTRA SEGMENT
BLOCK2 DB 9 DUP(?)
EXTRA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA,ES:EXTRA
START:MOV AX,DATA
MOV DS,AX
MOV AX,EXTRA
MOV ES,AX
LEA SI,BLOCK1
LEA Di,BLOCK2+8
MOV CX,00009H
BACK:
CLD
LODSB
STD
STOSB
LOOP BACK
LEA SI,BLOCK1
LEA DI,BLOCK2
MOV CX,0009H
CLD
REPZ CMPSB
JNZ SKIP
PRINT MSG1
SKIP: PRINT MSG2
CODE ENDS
END START

 


Page # 15
10. String concatenation
DATA SEGMENT
STR1 DB "HELLOS"
STR2 DB "WORLDS"
DATA ENDS
CODE SEGMENT
ASSUME DS:DATA,CS:CODE
START:
MOV AX,DATA
MOV DS,AX
MOV SI,OFFSET STR1
NEXT:
MOV ALSI]
CMP AL,"S"
JE EXIT ;IF AL=="$" ,THE IT WILL JUMP TO EXIT
INC SI
JMP NEXT
EXIT: MOV DI, OFFSET STR2
UP: MOV AL, [DI]
CMP AL,"S"
JE EXIT1
MOV [SI], AL
INC SI
INC DI
JMP UP
EXIT 1:
MOV AL,"S"
MOV [SI], AL
MOV AH,4CH
CODE ENDS
END START

11. Count number of ‘0’ and ‘1’ in a 16-bit number

DATA SEGMENT
NO DW 3H
Z DW?
ODW?
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
MOV AX,DATA
MOV DS,AX
MOV AX,NO
MOV BX,00H
MOV CX,10H
MOV DX,00H
UP:
ROL AX,1
JC ONE
INC BX
JMP NEXT
ONE:
INC DX
NEXT:
DEC Cx
JNZ UP
MOV Z,BX
MOV O,DX
INT 3
CODE ENDS
END START

 


